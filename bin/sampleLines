#!/bin/bash
shopt -qs extglob

printUsage()
{
    cat <<HELPTEXT
Select and print a line from standard input only once every second / TIMESPAN;
discard additional lines.
    --inline|-i		Overwrite the existing terminal line instead of
			accumulating the sampled lines in the output.
    --clear|-c		Also clear the single-line output after all input has
			been processed (so nothing remains to be seen, all
			samples were temporary only).
    --summarize|-s WHAT	Instead of printing selected output, just summarize the
			amount of lines (characterized as WHAT, e.g. "lines",
			"files").
HELPTEXT
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-i|--inline [-c|--clear]] [-s|--summarize WHAT] [-t|--timespan TIMESPAN[SUFFIX]] [-?|-h|--help]'
}

prefix=
suffix='\n'
finalizer=
isInline=
isClear=
summarizeWhat=
timespan=1
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--inline|-i)	shift; isInline=t; prefix='[1G[2K'; suffix=; finalizer='\n';;
	--clear|-c)	shift; isClear=t;;
	--summarize|-s)	shift; summarizeWhat="$1"; shift;;
	--timespan|-t)	shift
			case "$1" in
			    +([0-9])?(s))   timespan="${1%s}";;
			    +([0-9])m)	    timespan=$((${1%m} * 60));;
			    +([0-9])h)	    timespan=$((${1%h} * 3600));;
			    +([0-9])d)	    timespan=$((${1%d} * 86400));;
			esac
			shift
			;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
[ "$isClear" ] && finalizer='[1G[2K'

SECONDS=0
let prevC=-1
let c=0
isAgain=

while IFS=$'\n' read -r line || { suffix=; [ -n "$line" ]; }
do
    let c+=1
    if [ $SECONDS -ge $timespan ]; then
	sample="$line"
	if [ "$summarizeWhat" ]; then
	    sample="$c $summarizeWhat"

	    if [ -n "$isInline" -a $prevC -eq $c -a -z "$isAgain" ]; then
		# As the current line is overwritten, updates with the same
		# count could not be distinguished. For better usability, append
		# the word "again" on every other update with the same count, so
		# that it toggles on and off for successive same counts.
		isAgain=t
		sample="$sample again"
	    else
		isAgain=
	    fi
	fi

	printf "${prefix}%s${suffix}" "$sample"

	SECONDS=0
	let prevC=$c
	let c=0
    fi
done
if [ "$finalizer" ]; then
    printf "$finalizer"
fi
