#!/bin/bash
shopt -qs extglob

if [ -t 1 ]; then
    : ${SAMPLELINES_RESET_PREFIX=[01m}
    : ${SAMPLELINES_RESET_SUFFIX=[0m}
    : ${SAMPLELINES_APPEND_RESET_PREFIX=[01m}
    : ${SAMPLELINES_APPEND_RESET_SUFFIX='[0m '}
    : ${SAMPLELINES_SUMMARY_PREFIX=[36m}
    : ${SAMPLELINES_SUMMARY_SUFFIX='[0m '}
else
    : ${SAMPLELINES_RESET_PREFIX=}
    : ${SAMPLELINES_RESET_SUFFIX=}
    : ${SAMPLELINES_APPEND_RESET_PREFIX=}
    : ${SAMPLELINES_APPEND_RESET_SUFFIX=' '}
    : ${SAMPLELINES_SUMMARY_PREFIX=}
    : ${SAMPLELINES_SUMMARY_SUFFIX=' '}
fi


printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-r|--reset-on PATTERN] [-i|--inline-or-non|--inline-or-passthrough|-I|--inline-always [--inline-prefix IP] [-c|--clear] [-a|--append-reset|-k|--keep-reset]] [-s|--summarize WHAT[,PLURAL-WHAT] --summary-only] [-t|--timespan TIMESPAN[SUFFIX]] [-T|--initial-delay TIMESPAN[SUFFIX]] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 'Try %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Select and print a line from standard input only once every second / TIMESPAN;
discard additional lines.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --reset-on|-r PATTERN
			Reset the sampling interval on lines matching PATTERN,
			and and unconditionally print these lines.
    --inline-or-none|-i	Overwrite the existing terminal line instead of
			accumulating the sampled lines in the output.
			When not outputting to a terminal, suppress all output.
    --inline-or-passthrough
			Like above, but when not outputting to a terminal,
			forward all input unfiltered.
    --inline-always|-I	Like above, but also overwrite existing terminal lines
			even when not outputting to a terminal.
    --inline-prefix IP	Put IP before each inline output of a sampled line.
    --clear|-c		Also clear the single-line output after all input has
			been processed (so nothing remains to be seen, all
			samples were temporary only).
    --append-reset|-a	Append the reset line to all following inline updates,
			as a kind of context.
    --keep-reset|-k	Do not overwrite the existing sample line for reset
			lines. This has the effect of keeping a log of all reset
			lines (which could be informative headers or some other
			crucial context), and continuing the inline sampling
			below.
    --summarize|-s WHAT[,PLURAL-WHAT]
			Before printing selected output, also summarize the
			amount of lines (characterized as WHAT, e.g. "line",
			"file", you can also pass a separate (non-regular)
			plural form: "entry,entries") that were skipped before
			the current sample.
    --summary-only	Instead of printing summary and selected output, just
			summarize the amount of lines.
    --timespan|-t TIMESPAN[SUFFIX]
			Print a line every TIMESPAN instead of every second.
			SUFFIX may be 's' for seconds (the default), 'm' for
			minutes, 'h' for hours or 'd' for days.
    --initial-delay|-T TIMESPAN[SUFFIX]
			Wait for TIMESPAN before printing anything. By default,
			the first line is printed immediately.
Example:
HELPTEXT

    printf 'tail -f file | %q %s\n' "$(basename "$1")" '--inline-or-none --clear >&2'
}
timeToSeconds()
{
    case "$1" in
	+([0-9])?(s))   time="${1%s}";;
	+([0-9])m)	time=$((${1%m} * 60));;
	+([0-9])h)	time=$((${1%h} * 3600));;
	+([0-9])d)	time=$((${1%d} * 86400));;
	*)		printf >&2 'ERROR: Illegal timespan: %s\n' "$1"; exit 2;;
    esac
    printf %s "$time"
}

prefix=
suffix='\n'
finalizer=
resetPattern=
resetAction=
isInline=
inlinePrefix=
isClear=
summarizeWhat=
summarizeWhatPlural=
isSummaryOnly=
timespan=1
initialDelay=0
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--reset-pattern|-r)
			shift; resetPattern="$1"; shift;;
	--append-reset|-a)
			shift; resetAction=append;;
	--keep-reset|-k)
			shift; resetAction=keep;;
	--inline-always|-I)
			shift; isInline=t;;
	--inline-or-passthrough)
			shift
			[ -t 1 ] || exec cat
			isInline=t
			;;
	--inline-or-none|-i)
			shift
			[ -t 1 ] || exec cat > /dev/null
			isInline=t
			;;
	--inline-prefix)
			shift; inlinePrefix="$1"; shift;;
	--clear|-c)	shift; isClear=t;;
	--summarize|-s)	shift
			case "$1" in
			    *,*)    summarizeWhat="${1%%,*}"
				    summarizeWhatPlural="${1#*,}"
				    ;;
			    *)	    summarizeWhat="$1"
				    summarizeWhatPlural="${1}s"
				    ;;
			    esac
			shift
			;;
	--summary-only)	shift; isSummaryOnly=t;;
	--timespan|-t)	shift; timespan="$(timeToSeconds "$1")" || exit $?; shift;;
	--initial-delay|-T)
			shift; initialDelay="$(timeToSeconds "$1")" || exit $?; shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ ! "$isInline" -a -n "$inlinePrefix" ]; then
    echo >&2 'ERROR: --inline-prefix only works in conjunction with an --inline-... option.'
    echo >&2
    printShortUsage "$0" >&2
    exit 2
fi
if [ "$isInline" ]; then prefix="[1G[2K$inlinePrefix"; suffix=; finalizer='\n'; fi
[ "$isClear" ] && finalizer='[1G[2K'

SECONDS=$((timespan - initialDelay))
let previousCount=-1
let total=0
let count=0
isAgain=

keepResetPrefix=
while IFS=$'\n' read -r line || { [ "$summarizeWhat" ] || suffix=; [ -n "$line" ]; }
do
    let count+=1
    let total+=1
    isTakeThisLine=''
    keepResetSuffix=
    if [ "$resetPattern" ] && [[ "$line" =~ $resetPattern ]]; then
	isTakeThisLine=t
	line="${SAMPLELINES_RESET_PREFIX}${line}${SAMPLELINES_RESET_SUFFIX}"
	[ -n "$isInline" ] && case "$resetAction" in
	    append) keepResetPrefix=;;	# The current iteration already has the header in the line. Only prepend the header to subsequent samples.
	    keep)   keepResetSuffix='\n';;
	esac
    fi

    if [ -n "$isTakeThisLine" -o $SECONDS -ge $timespan ]; then
	sample="$line"
	if [ "$summarizeWhat" ]; then
	    if [ "$isSummaryOnly" ]; then
		summarySuffix=
	    else
		summarySuffix=' omitted'
		let count-=1    # Don't include the current line (that is printed) in the count.
	    fi

	    if [ $count -eq 0 ]; then
		summary=
	    elif [ $count -eq 1 ]; then
		summary="$count ${summarizeWhat}$summarySuffix"
	    else
		summary="$count ${summarizeWhatPlural}$summarySuffix"
	    fi

	    if [ -n "$summary" -a -n "$isInline" -a $previousCount -eq $count -a -z "$isAgain" ]; then
		# As the current line is overwritten, updates with the same
		# count could not be distinguished. For better usability, append
		# the word "again" on every other update with the same count, so
		# that it toggles on and off for successive same counts.
		isAgain=t
		summary="$summary again"
	    else
		isAgain=
	    fi

	    if [ "$isSummaryOnly" ]; then
		sample="$summary"
	    elif [ ! "$isTakeThisLine" ]; then
		sample="${summary:+"${SAMPLELINES_SUMMARY_PREFIX}(${summary})${SAMPLELINES_SUMMARY_SUFFIX}"}$line"
	    fi
	fi

	printf "${prefix}%s%s${suffix}${keepResetSuffix}" "$keepResetPrefix" "$sample"

	SECONDS=0
	let previousCount=$count
	let count=0
	[ -n "$isInline" -a -n "$isTakeThisLine" -a "$resetAction" = append ] && \
	    keepResetPrefix="${SAMPLELINES_APPEND_RESET_PREFIX}${line}${SAMPLELINES_APPEND_RESET_SUFFIX}"    # Prepend the header to subsequent samples now.
    fi
done

if [ "$summarizeWhat" ]; then
    if [ $total -eq 1 ]; then
	summary="$total $summarizeWhat"
    else
	summary="$total $summarizeWhatPlural"
    fi
    printf "${prefix}${SAMPLELINES_SUMMARY_PREFIX}%s${SAMPLELINES_SUMMARY_SUFFIX}${suffix}" "$summary in total"
fi
if [ "$finalizer" ]; then
    printf "$finalizer"
fi
