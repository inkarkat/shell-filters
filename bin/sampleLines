#!/bin/bash
shopt -qs extglob

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-i|--inline [-c|--clear]] [-s|--summarize WHAT[,PLURAL-WHAT]] [-t|--timespan TIMESPAN[SUFFIX]] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 'Try %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Select and print a line from standard input only once every second / TIMESPAN;
discard additional lines.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --inline|-i		Overwrite the existing terminal line instead of
			accumulating the sampled lines in the output.
    --clear|-c		Also clear the single-line output after all input has
			been processed (so nothing remains to be seen, all
			samples were temporary only).
    --summarize|-s WHAT[,PLURAL-WHAT]
			Instead of printing selected output, just summarize the
			amount of lines (characterized as WHAT, e.g. "line",
			"file", you can also pass a separate (non-regular)
			plural form:
			"entry,entries").
HELPTEXT
}

prefix=
suffix='\n'
finalizer=
isInline=
isClear=
summarizeWhat=
summarizeWhatPlural=
timespan=1
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--inline|-i)	shift; isInline=t; prefix='[1G[2K'; suffix=; finalizer='\n';;
	--clear|-c)	shift; isClear=t;;
	--summarize|-s)	shift
			case "$1" in
			    *,*)    summarizeWhat="${1%%,*}"
				    summarizeWhatPlural="${1#*,}"
				    ;;
			    *)	    summarizeWhat="$1"
				    summarizeWhatPlural="${1}s"
				    ;;
			    esac
			shift
			;;
	--timespan|-t)	shift
			case "$1" in
			    +([0-9])?(s))   timespan="${1%s}";;
			    +([0-9])m)	    timespan=$((${1%m} * 60));;
			    +([0-9])h)	    timespan=$((${1%h} * 3600));;
			    +([0-9])d)	    timespan=$((${1%d} * 86400));;
			esac
			shift
			;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
[ "$isClear" ] && finalizer='[1G[2K'

SECONDS=0
let prevC=-1
let c=0
isAgain=

while IFS=$'\n' read -r line || { suffix=; [ -n "$line" ]; }
do
    let c+=1
    if [ $SECONDS -ge $timespan ]; then
	sample="$line"
	if [ "$summarizeWhat" ]; then
	    if [ $c -eq 1 ]; then
		sample="$c $summarizeWhat"
	    else
		sample="$c $summarizeWhatPlural"
	    fi

	    if [ -n "$isInline" -a $prevC -eq $c -a -z "$isAgain" ]; then
		# As the current line is overwritten, updates with the same
		# count could not be distinguished. For better usability, append
		# the word "again" on every other update with the same count, so
		# that it toggles on and off for successive same counts.
		isAgain=t
		sample="$sample again"
	    else
		isAgain=
	    fi
	fi

	printf "${prefix}%s${suffix}" "$sample"

	SECONDS=0
	let prevC=$c
	let c=0
    fi
done
if [ "$finalizer" ]; then
    printf "$finalizer"
fi
