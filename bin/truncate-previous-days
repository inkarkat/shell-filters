#!/bin/bash

typeset -a monthsList=(none Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec)
readonly months='\(Jan\|Feb\|Mar\|Apr\|May\|Jun\|Jul\|Aug\|Sep\|Oct\|Nov\|Dec\)'
readonly weekdays='\(Mon\|Tue\|Wed\|Thu\|Fri\|Sat\|Sun\)'

readonly yearPattern='[12][0-9][0-9][0-9]'
readonly monthPattern='[01][0-9]'
readonly zeroedDayPattern='[0123][0-9]'
readonly dayPattern='[ 0123][0-9]'

typeset -A patterns=
patterns[iso]="${yearPattern}-${monthPattern}-${zeroedDayPattern}"
patterns[weekDayMonthDay]="${weekdays} ${months} ${dayPattern}"
patterns[american]="${monthPattern}\\/${zeroedDayPattern}\\/${yearPattern}"



printUsage()
{
    cat <<HELPTEXT
Remove all lines from the passed FILEs that precede the passed date in
YYYY-MM-DD format. Inside the FILEs, looks for the following date formats:
- 2017-09-22
- Fri Sep 22
- 09/22/2017
Files that do not contain any dates at all are skipped. Files that only contain
other dates are removed.
HELPTEXT
printf 'Usage: %q %s\n' "$(basename "$1")" 'YYYY-MM-DD FILE [...] [-?|-h|--help]'
}

typeset -a truncateLinesArguments=()
case "$1" in
    --help|-h|-\?)	shift; printUsage "$0"; exit 0;;
    --verbose-color|--verbose|-v)	truncateLinesArguments+=("$1"); shift;;
esac

case "$1" in
    ${yearPattern}-${monthPattern}-${zeroedDayPattern})
	year="${1:0:4}"
	month="${1:5:2}"
	day="${1:8:2}"

	typeset -A date=
	date[iso]="$1"
	date[american]="${month}\\/${day}\\/${year}"
	date[weekDayMonthDay]="${weekdays} ${monthsList[${month#0}]} ${day/#0/[0 ]}"
	;;
    '')	echo >&2 "ERROR: No date (YYYY-MM-DD) passed."; exit 2;;
    *)	echo >&2 "ERROR: Wrong date format, must be YYYY-MM-DD."; exit 2;;
esac
shift

[ $# -gt 0 ] || { printUsage "$0"; exit 2; }



readonly bs='\(^\|[^0-9a-zA-Z_-]\)' # keyword boundary start
readonly be='\($\|[^0-9a-zA-Z_-]\)' # keyword boundary end

considerArg=
typeset -a matchArgs=()
for format in iso american weekDayMonthDay
do
    considerArg="${considerArg}${considerArg:+\\}${patterns[$format]}"
    matchArgs+=('--match' "/${bs}${date[$format]}${be}/" -n "/${bs}${date[$format]}${be}/,\$p")
done

exec truncate-lines \
    "${truncateLinesArguments[@]}" \
    --consider "/${bs}\\(${considerArg}\\)${be}/" \
    "${matchArgs[@]}" \
    --else-delete \
    -- "$@"
