#!/bin/bash
shopt -qs extglob

: ${EXTRACTMATCHES_REPORT_MARKER='{}'}
reportMarker="$EXTRACTMATCHES_REPORT_MARKER"; unset EXTRACTMATCHES_REPORT_MARKER
: ${EXTRACTMATCHES_FILE_MARKER='{FILENAME}'}
fileMarker="$EXTRACTMATCHES_FILE_MARKER"; unset EXTRACTMATCHES_FILE_MARKER
: ${EXTRACTMATCHES_LINE_NUMBER_MARKER='{FNR}'}
lineNumberMarker="$EXTRACTMATCHES_LINE_NUMBER_MARKER"; unset EXTRACTMATCHES_LINE_NUMBER_MARKER

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-u|--unbuffered] [-q|--quiet] [-y|--summary|-Y|--summary-only] [[--name-percentage-threshold N] -%|--name-percentages NAME|/NAME-PATTERN/ [...]] [-t|--to overlay [--clear]|title|stderr|concatenated|command|notify|highlight|flash|FILE|--grep-only-matching|--grep-count] [-s|--skip PATTERN [...]] [-o|--report-order by-arg|count-desc] (-e|--regexp [-r|--replacement REPLACEMENT] [-g|--global] [-p|--priority N] [-n|--name NAME] [-k|--reset-other NAME|/NAME-PATTERN/] [-x|--reset RESET-PATTERN [-k|--reset-other NAME|/NAME-PATTERN/]])(-c|--count|-M|--match-count [-r|--replacement REPLACEMENT] [-g|--global] [-p|--priority N] [-n|--name NAME] [-k|--reset-other NAME|/NAME-PATTERN/] [-x|--reset RESET-PATTERN [-k|--reset-other NAME|/NAME-PATTERN/]])(--reset-name PATTERN [-g|--global] -n|--name NAME|/NAME-PATTERN/) [...] [--] FILE [...][-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Locate passed PATTERNs in the input and duplicate the last of (or count
occurrences of) them to overlaid text in the terminal / the terminal's window
title, in order to emphasize and persist the information.
Useful to alert the user to crucial events (like application exceptions, or the
number of fatal errors) when watching a log file.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --to|-t overlay	    Report in the form of overlaid text, written via
			    ANSI escape sequences in the first line of the
			    terminal (current line with --quiet, and also no
			    default highlighting then, so that combination looks
			    more like live reporting than an actual overlay).
    --clear		    Clear the overlay at the end.
    --to|-t title	    Report in the terminal's window title via ANSI
			    escape sequences.
    --to|-t stderr	    Report as a single concatenated line (like with
			    overlay and title), but inline to standard error.
			    Set EXTRACTMATCHES_STDERR_UPDATE_DELAY to the
			    number of seconds between reports, or to the
			    negative number of input lines between reports.
    --to|-t concatenated    Report as a single concatenated line (like with
			    overlay and title), but inline directly in the
			    output (or to EXTRACTMATCHES_CONCATENATED_FILE)
			    whenever there are changes. Set
			    EXTRACTMATCHES_CONCATENATED_UPDATE_DELAY to the
			    number of seconds between reports, or to the
			    negative number of input lines between reports.
    --to|-t command	    Report by invoking EXTRACTMATCHES_COMMANDLINE while
			    ${reportMarker:+replacing $reportMarker with the overlay-like report,}
			    ${fileMarker:+$fileMarker with the name of the current input file,}
			    ${lineNumberMarker:+and $lineNumberMarker with the line number.}
    --to|-t notify	    Report via notify-send to the system's notification
			    system.
    --to|-t highlight	    Just highlight the match (and added count) in-line.
    --to|-t flash	    Briefly reverse and unreverse the match (and added
			    count) to highlight it. Must be used with
			    --unbuffered.
    --to|-t FILE	    Append the report to FILE. Set
			    EXTRACTMATCHES_FILE_UPDATE_MATCH_DELAY /
			    EXTRACTMATCHES_FILE_UPDATE_COUNT_DELAY to 0 for
			    immediate updates. Additionally pass --unbuffered to
			    observe the file contents immediately.
    --grep-only-matching    Immediately report only matches (and counts) to
			    standard output, so that the command works like
			    grep -o|--only-matching (but additionally with the
			    possibility to do replacements).
			    Shortcut for EXTRACTMATCHES_FILE_UPDATE_DELAY=0
			    EXTRACTMATCHES_FILE_UPDATE_COUNT_DELAY=0 --to
			    /dev/stdout --quiet.
    --grep-count	    Report only counts to standard output after
			    processing all input, so that the command works like
			    grep -c|--count. Matches are reported immediately,
			    like with --grep-only-matching.
			    Shortcut for --to /dev/stdout --summary-only.
    --regexp|-e PATTERN	    Report matches of PATTERN in a line.
    --count|-c PATTERN	    Report the number of matches of PATTERN in a line.
    --match-count|-M PATTERN
			    Report the number of identical matches of PATTERN.
    --reset-name PATTERN    Clear the reporting / count of matches for NAME or
			    /NAME-PATTERN/ when PATTERN is encountered. This
			    affects any other rule through NAME.
    --reset|-x RESET-PATTERN
			    Clear the reporting / count of matches for PATTERN
			    when RESET-PATTERN is encountered. This is connected
			    to the corresponding --regexp|--count|--match-count.
    --reset-other|-k NAME|/NAME-PATTERN/
			    Also clear the reporting / count of matches for NAME
			    or /NAME-PATTERN/ when reporting (or resetting, if
			    passed after --reset) this match / count. This
			    affects any other rule through NAME.
    --name|-n NAME	    Tweak the counting / resetting.
			    --regexp|-e:      Clear reporting (potentially of
					      several instances) via
					      --reset-name.
			    --count|-c:       Prepend NAME- to PATTERN for
					      keeping counts.
			    --match-count|-M: Prepend NAME- to the match for
					      keeping counts.
			    --reset-name|-x:  Clear the reporting / count for
					      NAME (or all names matching
					      /NAME-PATTERN/).
    --replacement|-r REPLACEMENT
			    Use REPLACEMENT (that can refer to PATTERN capture
			    groups via \1 etc.) instead of the original match
			    (for reporting with --regexp and --count, for
			    counting with --match-count)
    --global|-g		    Report / count all occurrences of PATTERN in a line,
			    not just the first one.
    --priority|-p N	    Only report the match / count if previous one(s) had
			    the same or lower priority. (Default priority is 0.)
			    A --reset[-name] lowers the baseline priority to 1
			    below the associated priority.
    --skip|-s PATTERN	    Ignore (but still print) lines that match PATTERN,
			    so that these don't disrupt the processing of
			    surrounding lines.
    --report-order|-o by-arg
			    In case the reporting happens only periodically,
			    sort the number of matches first by order of the
			    --count / --match-count arguments as given on the
			    command-line, then by the count report itself, with
			    matches sorted alphanumerically.
    --report-order|-o count-desc
			    In case the reporting happens only periodically,
			    sort the number of matches from highest to lowest.
    --unbuffered|-u	    Immediately output each read line.
    --quiet|-q		    Do not output the input text, just the reporting.
    --summary|-y	    For stderr, concatenated, command, notify, or file
			    reporting, only report once at the very end of the
			    input file(s) instead of continuously.
    --summary-only|-Y	    For stderr, concatenated, command, notify, or file
			    reporting, do not print the input text, only the
			    report after processing all input.
    --name-percentages|-% NAME|/NAME-PATTERN/
			    After the reported count, also include the
			    percentage that a count for something starting with
			    NAME or matching /NAME-PATTERN/ represents (from
			    that group of named counts).
    --name-percentage-threshold N
			    Only report counts and percentages if the percentage
			    is at least N%; i.e. omit infrequent NAMEs. This
			    applies to all following --name-percentages
			    arguments.
All PATTERNs are AWK-style extended regular expressions.

Example:
HELPTEXT
    printf '%q %s\n' "$(basename "$1")" '--regexp "FATAL:.*" --name err --regexp "ERROR:.*" --name err --count Restarted --reset Restarted --name err'
}
singleRenderCheck()
{
    if [ "$render" ]; then
	echo "ERROR: There can be only one --to / --grep-..."
	echo
	printUsage "$1"
	exit 2
    fi >&2
}

getCountPrefix()
{
    case "$originalRender" in
	highlight|flash)				printf ' (';;
	overlay|title|command|notify)			printf ':';;
	stderr|concatenated|*)				printf ': ';;
    esac
}
getMatchBeforeCount()
{
    case "$originalRender" in
	overlay|title|stderr|concatenated|command|notify)   printf '';;
	highlight|flash|*)				    printf 't';;
    esac
}
getCountSuffix()
{
    case "$originalRender" in
	highlight|flash)				printf ')';;
	overlay|title|stderr|concatenated|command)	printf '';;
	notify|*)					printf '';;
    esac
}
setInfiniteDelays()
{
    EXTRACTMATCHES_STDERR_UPDATE_DELAY=2147483647
    EXTRACTMATCHES_CONCATENATED_UPDATE_DELAY=2147483647
    EXTRACTMATCHES_COMMAND_UPDATE_DELAY=2147483647
    EXTRACTMATCHES_NOTIFY_UPDATE_DELAY=2147483647
    EXTRACTMATCHES_FILE_UPDATE_MATCH_DELAY=2147483647
    EXTRACTMATCHES_FILE_UPDATE_COUNT_DELAY=2147483647
}
literalAwkExtendedPattern()
{
    printf %s "${1?}" | sed -e 's/\\/\\\\\\\\/g' -e 's/[][$*+?{}.|()^]/\\\\&/g'
}

: ${EXTRACTMATCHES_OVERLAY_JUMP=[s[1;1H}
: ${EXTRACTMATCHES_OVERLAY_PREFIX=[37;44m[}
: ${EXTRACTMATCHES_OVERLAY_SEPARATOR=|}
: ${EXTRACTMATCHES_OVERLAY_SUFFIX=][0m}
: ${EXTRACTMATCHES_OVERLAY_ERASE=}
: ${EXTRACTMATCHES_OVERLAY_RETURN=[u}
: ${EXTRACTMATCHES_OVERLAY_CLEAR=[s[1;1H[0K[u}
: ${EXTRACTMATCHES_OVERLAY_QUIET_JUMP=[1G}
: ${EXTRACTMATCHES_OVERLAY_QUIET_PREFIX=[}
: ${EXTRACTMATCHES_OVERLAY_QUIET_SEPARATOR=|}
: ${EXTRACTMATCHES_OVERLAY_QUIET_SUFFIX=]}
: ${EXTRACTMATCHES_OVERLAY_QUIET_ERASE=[0K}
: ${EXTRACTMATCHES_OVERLAY_QUIET_RETURN=}
: ${EXTRACTMATCHES_OVERLAY_QUIET_CLEAR=[1G[0K}
case "$TERM" in
    screen*)
	: ${EXTRACTMATCHES_TITLE_SET=']2;'}
	: ${EXTRACTMATCHES_TITLE_FINISH='\'}
	;;
    linux)
	# The Linux kernel console doesn't have a title, as it runs full-screen.
	printf >&2 'ERROR: Cannot drive terminal title with TERM=%s\n' "$TERM"
	exit 3
	;;
    *)
	: ${EXTRACTMATCHES_TITLE_SET=']2;'}
	: ${EXTRACTMATCHES_TITLE_FINISH=''}
	;;
esac
EXEC=exec
: ${EXTRACTMATCHES_TITLE_UPDATE_DELAY:=0}
: ${EXTRACTMATCHES_TITLE_PREFIX=[}
: ${EXTRACTMATCHES_TITLE_SEPARATOR=|}
: ${EXTRACTMATCHES_TITLE_SUFFIX=]}
: ${EXTRACTMATCHES_STDERR_UPDATE_DELAY:=0}
: ${EXTRACTMATCHES_STDERR_PREFIX=extracted matches: }
: ${EXTRACTMATCHES_STDERR_SEPARATOR=, }
: ${EXTRACTMATCHES_STDERR_SUFFIX=$'\n'}
: ${EXTRACTMATCHES_CONCATENATED_UPDATE_DELAY:=0}
: ${EXTRACTMATCHES_CONCATENATED_PREFIX=extracted matches: }
: ${EXTRACTMATCHES_CONCATENATED_SEPARATOR=, }
: ${EXTRACTMATCHES_CONCATENATED_SUFFIX=$'\n'}
: ${EXTRACTMATCHES_COMMAND_SEPARATOR=|}
: ${EXTRACTMATCHES_COMMAND_UPDATE_DELAY:=1}
: ${EXTRACTMATCHES_NOTIFY_SEND:=notify-send}
: ${EXTRACTMATCHES_NOTIFY_SEPARATOR=, }
: ${EXTRACTMATCHES_NOTIFY_UPDATE_DELAY:=10}
: ${EXTRACTMATCHES_FILE_UPDATE_MATCH_DELAY:=1}
: ${EXTRACTMATCHES_FILE_UPDATE_COUNT_DELAY:=1}
: ${EXTRACTMATCHES_FILE_PREFIX_EXPR:=}
: ${EXTRACTMATCHES_FILE_SUFFIX_EXPR:=}
: ${EXTRACTMATCHES_FILE_CLEAR_MATCH_TEMPLATE='Off: &'}
: ${EXTRACTMATCHES_FLASH_ON_TIME:=0.1}
: ${EXTRACTMATCHES_FLASH_OFF_TIME:=0.2}
: ${EXTRACTMATCHES_FLASH_REPEATS:=3}
: ${EXTRACTMATCHES_HIGHLIGHT_PREFIX=[07m}
: ${EXTRACTMATCHES_HIGHLIGHT_SUFFIX=[0m}
: ${EXTRACTMATCHES_NAME_PERCENTAGES_TEMPLATE:='\1 = \2%'}
: ${EXTRACTMATCHES_NAME_PERCENTAGES_SINGLE_DIGIT_PRECISION:=1}
: ${EXTRACTMATCHES_NAME_PERCENTAGES_MULTI_DIGIT_PRECISION:=0}
render=
skipPattern=
typeset -a types=()
typeset -a patterns=()
typeset -a replacements=()
typeset -a globals=()
typeset -a others=()
typeset -a names=()
typeset -a priorities=()
currentNamePercentageThreshold=0
typeset -a namePercentages=()
typeset -a namePercentageThresholds=()
isBuffered=t; [ -t 1 ] && isBuffered=
isClear=
isQuiet=
reportOrder='compareByKeyArgumentOrder'
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--to|-t)	shift; singleRenderCheck "$0"; render="$1"; shift;;
	--grep-only-matching)	shift; singleRenderCheck "$0"; render='/dev/stdout'; isQuiet=t; EXTRACTMATCHES_FILE_UPDATE_MATCH_DELAY=0; EXTRACTMATCHES_FILE_UPDATE_COUNT_DELAY=0;;
	--grep-count)		shift; singleRenderCheck "$0"; render='/dev/stdout'; isQuiet=t; setInfiniteDelays; EXTRACTMATCHES_FILE_UPDATE_MATCH_DELAY=0;;
	--skip|-s)	shift; skipPattern="${skipPattern}${skipPattern:+|}${1:?}"; shift;;
	--regexp|-e)		shift; types+=(regexp); patterns+=("${1:?}"); replacements+=('&'); globals+=(0); others+=(''); names+=('') priorities+=(0); shift;;
	--count|-c)		shift; types+=(count); patterns+=("${1:?}"); replacements+=('&'); globals+=(0); others+=(''); names+=('') priorities+=(0); shift;;
	--match-count|-M)	shift; types+=(match-count); patterns+=("${1:?}"); replacements+=('&'); globals+=(0); others+=(''); names+=('') priorities+=(0); shift;;
	--reset-name)		shift; types+=(reset-name); patterns+=("${1:?}"); replacements+=('&'); globals+=(0); others+=(''); names+=('') priorities+=(0); shift;;
	--reset|-x)		shift
				if [ ${#types[@]} -eq 0 ] || [ "${types[-1]}" = reset-name ]; then
				    echo "Need -e|--regexp|-c|--count|-M|--match-count PATTERN before passing RESET-PATTERN."
				    echo
				    printUsage "$0"
				    exit 2
				fi >&2
				types+=(reset); patterns+=("${1:?}"); replacements+=('&'); globals+=("${globals[-1]}"); others+=(''); priorities+=("${priorities[-1]}")	# Don't copy reset-other; as a following --reset-other can independently add a trigger for RESET-PATTERN.
				countPatternAppendix=; [ "${types[-2]}" = count ] && countPatternAppendix="-${patterns[-2]}"
				if [ "${names[-1]}" ]; then
				    names+=("${names[-1]}$countPatternAppendix")
				else
				    names=("${names[@]:0:$((${#names[@]} - 1))}" "${patterns[-2]}")
				    names+=("${patterns[-2]}$countPatternAppendix")
				fi
				shift
				;;
	--reset-other|-k)	shift
				if [ ${#types[@]} -eq 0 ] || [ "${types[-1]}" = reset-name ]; then
				    echo "Need -e|--regexp|-c|--count|-M|--match-count PATTERN before passing --reset-other NAME."
				    echo
				    printUsage "$0"
				    exit 2
				fi >&2
				others[-1]="$1"
				shift
				;;
	--replacement|-r)	shift
				if [ ${#types[@]} -eq 0 ] || [[ "${types[-1]}" = reset?(-name) ]]; then
				    echo "Need -e|--regexp|-c|--count|-M|--match-count PATTERN before passing REPLACEMENT."
				    echo
				    printUsage "$0"
				    exit 2
				fi >&2
				replacements[-1]="$1"
				shift
				;;
	--global|-g)		shift
				if [ ${#types[@]} -eq 0 ] || [ "${types[-1]}" = reset ]; then
				    echo "Need -e|--regexp|-c|--count|-M|--match-count PATTERN before passing -g|--global."
				    echo
				    printUsage "$0"
				    exit 2
				fi >&2
				globals[-1]=1
				;;
	--name|-n)		shift
				if [ ${#types[@]} -eq 0 ]; then
				    echo "Need -e|--regexp|-c|--count|-M|--match-count|--reset-name PATTERN before passing NAME."
				    echo
				    printUsage "$0"
				    exit 2
				fi >&2
				names[-1]="$1"
				shift
				;;
	--priority|-p)		shift
				if [ ${#types[@]} -eq 0 ]; then
				    echo "Need -e|--regexp|-c|-count|-M|--match-count|--reset-name PATTERN before passing PRIORITY."
				    echo
				    printUsage "$0"
				    exit 2
				elif [[ "$1" != ?(-)+([0-9]) ]]; then
				    echo "PRIORITY must be a number."
				    echo
				    printUsage "$0"
				    exit 2
				fi >&2
				priorities[-1]="$1"
				shift
				;;
	--unbuffered|-u)	shift; isBuffered=;;
	--clear)		shift; isClear=t;;
	--quiet|-q)		shift; isQuiet=t;;
	--summary-only|-Y)	isQuiet=t
				;&
	--summary|-y)		shift; setInfiniteDelays;;
	--report-order|-o)	shift
				case "$1" in
				    by-arg)	reportOrder='compareByKeyArgumentOrder';;
				    count-desc)	reportOrder='compareByCount';;
				    *)		echo >&2 "ERROR: Invalid report order."
						echo >&2
						printUsage "$0" >&2
						exit 2
						;;
				esac
				shift
				;;
	--name-percentage-threshold)
				shift; currentNamePercentageThreshold="$1"; shift;;
	--name-percentages|-%)	shift; namePercentages+=("$1"); namePercentageThresholds+=($currentNamePercentageThreshold); shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ ${#types[@]} -eq 0 ]; then
    echo 'ERROR: No -e|--regexp|-c|--count|-M|--match-count|-x|--reset passed.'
    echo
    printUsage "$0"
    exit 2
fi >&2
originalRender="${render:=highlight}"
if [ "$render" = 'notify' ]; then
    if [ -z "$EXTRACTMATCHES_NOTIFY_COMMANDLINE" ] && ! which "$EXTRACTMATCHES_NOTIFY_SEND" >/dev/null 2>&1; then
	printf >&2 'ERROR: notify-send command (%s) not found.\n' "$EXTRACTMATCHES_NOTIFY_SEND"
	exit 2
    fi
    : ${EXTRACTMATCHES_NOTIFY_COMMANDLINE:="\"$EXTRACTMATCHES_NOTIFY_SEND\"${EXTRACTMATCHES_NOTIFY_ARGUMENTS:+ $EXTRACTMATCHES_NOTIFY_ARGUMENTS} \"extractMatches {FILENAME}:{FNR}\" -- $reportMarker"}

    # Reuse the command renderer for notify-send; it has all the generic
    # functionality to do it.
    render='command'
    EXTRACTMATCHES_COMMANDLINE="$EXTRACTMATCHES_NOTIFY_COMMANDLINE"
    EXTRACTMATCHES_COMMAND_SEPARATOR="$EXTRACTMATCHES_NOTIFY_SEPARATOR"
    EXTRACTMATCHES_COMMAND_UPDATE_DELAY="$EXTRACTMATCHES_NOTIFY_UPDATE_DELAY"
elif [ "$render" = 'title' ]; then
    render='concatenated'
    EXTRACTMATCHES_CONCATENATED_UPDATE_DELAY="$EXTRACTMATCHES_TITLE_UPDATE_DELAY"
    EXTRACTMATCHES_CONCATENATED_SEPARATOR="$EXTRACTMATCHES_TITLE_SEPARATOR"
    EXTRACTMATCHES_CONCATENATED_PREFIX="${EXTRACTMATCHES_TITLE_SET}${EXTRACTMATCHES_TITLE_PREFIX}"
    EXTRACTMATCHES_CONCATENATED_SUFFIX="${EXTRACTMATCHES_TITLE_SUFFIX}${EXTRACTMATCHES_TITLE_FINISH}"
elif [ "$render" = 'stderr' ]; then
    render='concatenated'
    EXTRACTMATCHES_CONCATENATED_UPDATE_DELAY="$EXTRACTMATCHES_STDERR_UPDATE_DELAY"
    EXTRACTMATCHES_CONCATENATED_SEPARATOR="$EXTRACTMATCHES_STDERR_SEPARATOR"
    EXTRACTMATCHES_CONCATENATED_PREFIX="$EXTRACTMATCHES_STDERR_PREFIX"
    EXTRACTMATCHES_CONCATENATED_SUFFIX="$EXTRACTMATCHES_STDERR_SUFFIX"
fi
if [ "$isQuiet" ]; then
    extractmatchesOverlayJump="$EXTRACTMATCHES_OVERLAY_QUIET_JUMP"
    extractmatchesOverlayPrefix="$EXTRACTMATCHES_OVERLAY_QUIET_PREFIX"
    extractmatchesOverlaySeparator="$EXTRACTMATCHES_OVERLAY_QUIET_SEPARATOR"
    extractmatchesOverlaySuffix="$EXTRACTMATCHES_OVERLAY_QUIET_SUFFIX"
    extractmatchesOverlayErase="$EXTRACTMATCHES_OVERLAY_QUIET_ERASE"
    extractmatchesOverlayReturn="$EXTRACTMATCHES_OVERLAY_QUIET_RETURN"
    extractmatchesOverlayClear="$EXTRACTMATCHES_OVERLAY_QUIET_CLEAR"
else
    extractmatchesOverlayJump="$EXTRACTMATCHES_OVERLAY_JUMP"
    extractmatchesOverlayPrefix="$EXTRACTMATCHES_OVERLAY_PREFIX"
    extractmatchesOverlaySeparator="$EXTRACTMATCHES_OVERLAY_SEPARATOR"
    extractmatchesOverlaySuffix="$EXTRACTMATCHES_OVERLAY_SUFFIX"
    extractmatchesOverlayErase="$EXTRACTMATCHES_OVERLAY_ERASE"
    extractmatchesOverlayReturn="$EXTRACTMATCHES_OVERLAY_RETURN"
    extractmatchesOverlayClear="$EXTRACTMATCHES_OVERLAY_CLEAR"
fi
if [ "$render" = 'flash' ] && [ "$isBuffered" ]; then
    echo 'ERROR: Flash reporting must be combined with --unbuffered.'
    echo
    printUsage "$0"
    exit 2
elif [ "$render" != 'overlay' ] && [ "$isClear" ]; then
    echo 'ERROR: --clear must be combined with --to overlay.'
    echo
    printUsage "$0"
    exit 2
elif [ "$render" = 'command' ]; then
    if [ -z "$EXTRACTMATCHES_COMMANDLINE" ]; then
	echo 'ERROR: Command reporting must define EXTRACTMATCHES_COMMANDLINE.'
	exit 2
    fi
    if [ "$EXTRACTMATCHES_PRE_COMMANDLINE" ]; then
	eval "$EXTRACTMATCHES_PRE_COMMANDLINE" || exit $?
    fi
    if [ "$EXTRACTMATCHES_POST_COMMANDLINE" ]; then
	EXEC=
	trap "$EXTRACTMATCHES_POST_COMMANDLINE" EXIT
    fi
fi >&2
replacements+=(''); others+=(''); names+=('')	# Add one empty element so that split() will yield at least one in case of a single empty one.
: ${EXTRACTMATCHES_COUNT_PREFIX="$(getCountPrefix)"}
: ${EXTRACTMATCHES_COUNT_SUFFIX="$(getCountSuffix)"}
: ${EXTRACTMATCHES_MATCH_BEFORE_COUNT="$(getMatchBeforeCount)"}
file='/dev/stdout'
case "$originalRender" in
    command|notify|highlight|flash) ;;
    overlay|title)
	file="${EXTRACTMATCHES_SINK:-/dev/tty}";;
    stderr)
	file="/dev/stderr";;
    concatenated)
	file="${EXTRACTMATCHES_CONCATENATED_FILE:-$file}";;
    *)	file="$render"; render='file';;
esac

IFS=$'\n'
$EXEC awk \
    -v "reportMarker=$(literalAwkExtendedPattern "$reportMarker")" \
    -v "fileMarker=$(literalAwkExtendedPattern "$fileMarker")" \
    -v "lineNumberMarker=$(literalAwkExtendedPattern "$lineNumberMarker")" \
    -v "originalRender=$originalRender" \
    -v "render=$render" \
    -v "file=${file//\\/\\\\}" \
    -v "isBuffered=$isBuffered" \
    -v "isQuiet=$isQuiet" \
    -v "typeList=${types[*]}" \
    -v "patternList=${patterns[*]//\\/\\\\}" \
    -v "replacementList=${replacements[*]//\\/\\\\}" \
    -v "globalsList=${globals[*]//\\/\\\\}" \
    -v "othersList=${others[*]//\\/\\\\}" \
    -v "nameList=${names[*]//\\/\\\\}" \
    -v "priorityList=${priorities[*]//\\/\\\\}" \
    -v "namePercentageList=${namePercentages[*]//\\/\\\\}" \
    -v "namePercentageThresholdList=${namePercentageThresholds[*]}" \
    -v "namePercentageTemplate=${EXTRACTMATCHES_NAME_PERCENTAGES_TEMPLATE//\\/\\\\}" \
    -v "namePercentageSingleDigitPrecision=$EXTRACTMATCHES_NAME_PERCENTAGES_SINGLE_DIGIT_PRECISION" \
    -v "namePercentageMultiDigitPrecision=$EXTRACTMATCHES_NAME_PERCENTAGES_MULTI_DIGIT_PRECISION" \
    -v "skipPattern=${skipPattern//\\/\\\\}" \
    -v "reportOrder=${reportOrder//\\/\\\\}" \
    -v "overlayPrefix=${extractmatchesOverlayJump//\\/\\\\}${extractmatchesOverlayPrefix//\\/\\\\}" \
    -v "overlaySeparator=${extractmatchesOverlaySeparator//\\/\\\\}" \
    -v "overlaySuffix=${extractmatchesOverlaySuffix//\\/\\\\}${extractmatchesOverlayErase//\\/\\\\}${extractmatchesOverlayReturn//\\/\\\\}" \
    -v "overlayClear=${isClear:+${extractmatchesOverlayClear//\\/\\\\}}" \
    -v "concatenatedUpdateDelay=${EXTRACTMATCHES_CONCATENATED_UPDATE_DELAY}" \
    -v "concatenatedPrefix=${EXTRACTMATCHES_CONCATENATED_PREFIX//\\/\\\\}" \
    -v "concatenatedSeparator=${EXTRACTMATCHES_CONCATENATED_SEPARATOR//\\/\\\\}" \
    -v "concatenatedSuffix=${EXTRACTMATCHES_CONCATENATED_SUFFIX//\\/\\\\}" \
    -v "commandSeparator=${EXTRACTMATCHES_COMMAND_SEPARATOR//\\/\\\\}" \
    -v "commandLine=${EXTRACTMATCHES_COMMANDLINE//\\/\\\\}" \
    -v "commandUpdateDelay=${EXTRACTMATCHES_COMMAND_UPDATE_DELAY}" \
    -v "fileUpdateMatchDelay=${EXTRACTMATCHES_FILE_UPDATE_MATCH_DELAY}" \
    -v "fileUpdateCountDelay=${EXTRACTMATCHES_FILE_UPDATE_COUNT_DELAY}" \
    -v "filePrefixExpr=${EXTRACTMATCHES_FILE_PREFIX_EXPR}" \
    -v "fileSuffixExpr=${EXTRACTMATCHES_FILE_SUFFIX_EXPR}" \
    -v "fileClearMatchTemplate=${EXTRACTMATCHES_FILE_CLEAR_MATCH_TEMPLATE//\\/\\\\}" \
    -v "flashOnTime=${EXTRACTMATCHES_FLASH_ON_TIME}" \
    -v "flashOffTime=${EXTRACTMATCHES_FLASH_OFF_TIME}" \
    -v "flashRepeats=${EXTRACTMATCHES_FLASH_REPEATS}" \
    -v "highlightPrefix=${EXTRACTMATCHES_HIGHLIGHT_PREFIX//\\/\\\\}" \
    -v "highlightSuffix=${EXTRACTMATCHES_HIGHLIGHT_SUFFIX//\\/\\\\}" \
    -v "countPrefix=${EXTRACTMATCHES_COUNT_PREFIX//\\/\\\\}" \
    -v "countSuffix=${EXTRACTMATCHES_COUNT_SUFFIX//\\/\\\\}" \
    -v "isMatchBeforeCount=${EXTRACTMATCHES_MATCH_BEFORE_COUNT}" \
'
BEGIN {
    FS = "\n"
    split("", EMPTY_ARRAY)

    N = split(typeList, types)
    if (split(patternList, patterns) != N) {
	print "Assert: Mismatch in number of types and patterns." > "/dev/stderr"
	exit 3
    }
    if (split(globalsList, globals) != N) {
	print "Assert: Mismatch in number of globals and patterns." > "/dev/stderr"
	exit 3
    }
    if (split(othersList, others) != N + 1) {
	print "Assert: Mismatch in number of reset-others and patterns." > "/dev/stderr"
	exit 3
    }
    if (split(replacementList, replacements) != N + 1) {
	print "Assert: Mismatch in number of replacements and patterns." > "/dev/stderr"
	exit 3
    }
    if (split(nameList, names) != N + 1) {
	print "Assert: Mismatch in number of names and patterns." > "/dev/stderr"
	exit 3
    }
    if (split(priorityList, priorities) != N) {
	print "Assert: Mismatch in number of priorities and patterns." > "/dev/stderr"
	exit 3
    }

    namePercentagesNum = split(namePercentageList, namePercentages)
    if (split(namePercentageThresholdList, namePercentageThresholds) != namePercentagesNum) {
	print "Assert: Mismatch in number of named percentages and their thresholds." > "/dev/stderr"
	exit 3
    }

    PROCINFO["sorted_in"] = "@ind_str_asc"
    delete delayedCounts    # Reify as array; else, the length(delayedCounts) will create it as a scalar instead.
    delayTime = delayMatchTime = delayCountTime = systime()

    switch (originalRender) {
	case "overlay":
	case "title": {
	    # Suppress fatal error "cannot redirect to /dev/tty (No such device or address)" if the terminal is not available.
	    # Requires gawk 4.2.
	    PROCINFO[file, "NONFATAL"] = 1
	    break
	}
    }
}
function getKeyMatch(key)
{
    return gensub(/^.*-/, "", 1, key)   # XXX: For match-count, both PATTERN and TEXT could contain the dash separator, so the extraction is not perfect here.
}
function compareByKeyArgumentOrder(i1, v1, i2, v2,      index1, index2, text1, text2)
{
    # Sort first by order of pattern arguments as given on the command-line
    # (attribute "i"), then by the count text ascending (attribute "text").
    index1 = v1["i"]
    index2 = v2["i"]
    text1 = v1["text"]
    text2 = v2["text"]

    if (index1 == index2) {
	return (text1 == text2 ? 0 : text1 > text2 ? 1 : -1)
    } else {
	return (index1 == index2 ? 0 : index1 > index2 ? 1 : -1)
    }

}
function compareByCount(i1, v1, i2, v2,      count1, count2)
{
    # Sort first by count descending, then by count text ascending.
    count1 = v1["count"]
    count2 = v2["count"]
    text1 = v1["text"]
    text2 = v2["text"]

    if (count1 == count2) {
	return (text1 == text2 ? 0 : text1 > text2 ? 1 : -1)
    } else {
	return (count1 > count2 ? -1 : 1)
    }
}
function multiply(char, count,      tmp, i)
{
    for (i = 1; i <= count; ++i) tmp = tmp char
    return tmp
}
function flash(onText, offText,      deleter, i, prefix)
{
    deleter = multiply("", length(onText))

    for (i = 0; i < flashRepeats; ++i) {
	if (i > 0) {
	    printf "%s%s", deleter, onText
	    prefix = deleter
	    fflush()
	}

	system("sleep " flashOffTime)
	printf prefix "[07m%s[0m", onText
	fflush()
	system("sleep " flashOnTime)
    }
    return deleter offText
}
function pad(text, padding)
{
    return (text == "" ? "" : padding)
}
function replace(text, pattern, replacement)
{
    return (replacement == "&" ? text : gensub(pattern, replacement, "g", text))
}
function resetMatch(key)
{
    renderReset(key, matches[key], "regexp")
    matches[key] = 0
}
function resetCount(key)
{
    if (key == "") return
    renderReset(key, counts[key], "count")
    counts[key] = 0
}
function resetMatchCount(key)
{
    renderReset(key, matchCounts[key], "match-count")
    matchCounts[key] = 0
}
function resetCounts(key,      tmp)
{
    for (tmp in counts) {
	if (substr(tmp, 1, length(key)) == key) {
	    resetCount(tmp)
	}
    }
}
function resetMatchCounts(key,      tmp)
{
    if (key == "") return

    for (tmp in matchCounts) {
	if (substr(tmp, 1, length(key)) == key) {
	    resetMatchCount(tmp)
	}
    }
}
function evaluateShellExpression(expr,      commandLine, commandResult, output)
{
    if (expr == "") return ""

    commandLine = "printf %s \"" expr "\""
    commandResult = commandLine | getline output
    close(commandLine)
    if (commandResult == -1) {
	print "ERROR: Failed to evaluate expression \"" expr "\"." > "/dev/stderr"
	exit 3
    }
    return output
}
function writeToFile(text,      prefix, suffix)
{
    print evaluateShellExpression(filePrefixExpr) text evaluateShellExpression(fileSuffixExpr) > file
    if (! isBuffered) fflush(file)
}
function preRenderLine()
{
    switch (render) {
	case "overlay":
	case "concatenated":
	case "command":
	case "highlight":
	case "file":
	    break
	case "flash":
	    flashAdditionalWidth = 0
	    break
	default:
	    print "Assert: Invalid render: " render > "/dev/stderr"
	    exit 3
    }
}
function postRenderLine(      currentTime, isRenderMatchesNow, isRenderCountsNow, resultNum, resultList, i)
{
    switch (render) {
	case "overlay":
	case "concatenated":
	case "command":
	case "highlight":
	    break
	case "flash":
	    if (flashAdditionalWidth > 0) {
		$0 = $0 multiply(" ", flashAdditionalWidth) multiply("", flashAdditionalWidth)
	    }
	case "file":
	    currentTime = systime()
	    isRenderMatchesNow = ((fileUpdateMatchDelay < 0 && NR % fileUpdateMatchDelay == 0) || (fileUpdateMatchDelay > 0 && currentTime - delayMatchTime >= fileUpdateMatchDelay))
	    isRenderCountsNow = ((fileUpdateCountDelay < 0 && NR % fileUpdateCountDelay == 0) || (fileUpdateCountDelay > 0 && currentTime - delayCountTime >= fileUpdateCountDelay))
	    if (isRenderMatchesNow && isRenderCountsNow) {
		delayedFileRender()
	    } else {
		if (isRenderMatchesNow) {
		    resultNum = renderIt(delayedMatchReset, delayedMatch, EMPTY_ARRAY, resultList)
		    delayedMatchReset = ""
		    delayedMatch = ""
		    delayMatchTime = currentTime
		}
		if (isRenderCountsNow) {
		    resultNum = renderIt("", "", delayedCounts, resultList)
		    delete delayedCounts
		    delayCountTime = currentTime
		}
		for (i = 1; i <= resultNum; ++i) {
		    writeToFile(resultList[i])
		}
	    }
	    break
	default:
	    print "Assert: Invalid render: " render > "/dev/stderr"
	    exit 3
    }
}
function postLine()
{
    switch (render) {
	case "overlay":
	    delayedOverlayRender()
	    break
	case "concatenated":
	    if (concatenatedUpdateDelay == 0 || (concatenatedUpdateDelay < 0 && NR % concatenatedUpdateDelay == 0) || (concatenatedUpdateDelay > 0 && systime() - delayTime >= concatenatedUpdateDelay)) {
		delayedConcatenatedRender()
	    }
	    break
	case "command":
	    if (commandUpdateDelay == 0 || (commandUpdateDelay < 0 && NR % commandUpdateDelay == 0) || (commandUpdateDelay > 0 && systime() - delayTime >= commandUpdateDelay)) {
		delayedCommandRender()
	    }
	    break
	case "highlight":
	case "flash":
	case "file":
	    break
	default:
	    print "Assert: Invalid render: " render > "/dev/stderr"
	    exit 3
    }
}
function renderIt(theMatchReset, theMatch, theCounts, resultList,      resultCnt, key, save_sorted_in, countAndPercentage)
{
    if (isMatchBeforeCount && theMatchReset != "") {
	resultList[++resultCnt] = theMatchReset
    }
    if (isMatchBeforeCount && theMatch != "") {
	resultList[++resultCnt] = theMatch
    }

    if (length(theCounts) > 0) {
	save_sorted_in = PROCINFO["sorted_in"]
	PROCINFO["sorted_in"] = reportOrder
	    for (key in theCounts) {
		PROCINFO["sorted_in"] = save_sorted_in
		    countAndPercentage = addPercentage(key, theCounts[key]["count"])
		    if (countAndPercentage != "")
			resultList[++resultCnt] = theCounts[key]["text"] countPrefix countAndPercentage countSuffix
		PROCINFO["sorted_in"] = reportOrder
	    }
	PROCINFO["sorted_in"] = save_sorted_in
    }

    if (! isMatchBeforeCount && theMatchReset != "") {
	resultList[++resultCnt] = theMatchReset
    }
    if (! isMatchBeforeCount && theMatch != "") {
	resultList[++resultCnt] = theMatch
    }

    return resultCnt
}
function delayedRender(resultList,      resultCnt, key, save_sorted_in)
{
    return renderIt("", delayedMatch, delayedCounts, resultList)
}
function concatenateResults(separator,      resultNum, resultList, i, result)
{
    resultNum = delayedRender(resultList)
    for (i = 1; i <= resultNum; ++i) {
	result = result (result == "" ? "" : separator) resultList[i]
    }
    return result
}
function writeConcatenatedToFile(prefix, separator, suffix,      result)
{
    result = concatenateResults(separator)
    if (result == "") return

    printf "%s%s%s", prefix, result, suffix > file
    if (isBuffered) fflush(file)	# Flushing will happen for unbuffered output, anyway, but we need this for buffered one as well.
}
function delayedOverlayRender()
{
    writeConcatenatedToFile(overlayPrefix, overlaySeparator, overlaySuffix)
}
function delayedConcatenatedRender()
{
    if (! delayedChange) return

    writeConcatenatedToFile(concatenatedPrefix, concatenatedSeparator, concatenatedSuffix)

    delayedChange = 0
    delayTime = systime()
}
function delayedCommandRender(      result, reportingCommandLine, commandResult)
{
    if (! delayedChange) return

    result = concatenateResults(commandSeparator)
    if (result == "") return

    reportingCommandLine = commandLine
    if (reportMarker != "" && commandLine ~ reportMarker)
	reportingCommandLine = gensub(reportMarker, "\047" gensub("\047", "\047\\\\\\\\\047\047", "g", result) "\047", "g", reportingCommandLine)
    if (fileMarker != "" && commandLine ~ fileMarker)
	reportingCommandLine = gensub(fileMarker, FILENAME, "g", reportingCommandLine)
    if (lineNumberMarker != "" && commandLine ~ lineNumberMarker)
	reportingCommandLine = gensub(lineNumberMarker, FNR, "g", reportingCommandLine)

    if (commandResult = system(reportingCommandLine) != 0) {
	printf "ERROR: Failed to invoke \"%s\" (%d).\n", reportingCommandLine, commandResult  > "/dev/stderr"
	exit 3
    }

    delayedChange = 0
    delayTime = systime()
}
function delayedFileRender(      resultNum, resultList, i)
{
    resultNum = renderIt(delayedMatchReset, delayedMatch, delayedCounts, resultList)

    # The match / counts have been reported to the file; do not do this again for following lines (only new counts).
    delayedMatchReset = ""
    delayedMatch = ""
    delete delayedCounts

    for (i = 1; i <= resultNum; ++i) {
	writeToFile(resultList[i])
    }

    delayMatchTime = delayCountTime = systime()
}
function renderMatch(before, text, after)
{
    switch (render) {
	case "overlay":
	case "concatenated":
	case "command":
	    delayedChange = delayedChange || (delayedMatch != text)
	    delayedMatch = text
	    break
	case "highlight":
	    $0 = before highlightPrefix text highlightSuffix after
	    break
	case "flash":
	    if (isQuiet) {
		printf "%s", flash(text, text)
		fflush()
		$0 = after
	    } else {
		printf "%s", before
		$0 = flash(text, text) after
	    }
	    break
	case "file":
	    if (fileUpdateMatchDelay != 0) {
		delayedMatch = text
	    } else {
		writeToFile(text)
	    }
	    break
	default:
	    print "Assert: Invalid render: " render > "/dev/stderr"
	    exit 3
    }
}
function renderCount(key, before, text, count, after,      tmp, countAndPercentage)
{
    switch (render) {
	case "overlay":
	case "concatenated":
	case "command":
	    delayedChange = delayedChange || delayedCounts[key]["count"] != count || delayedCounts[key]["text"] != text
	    delayedCounts[key]["i"] = lowestI
	    delayedCounts[key]["count"] = count
	    delayedCounts[key]["text"] = text
	    break
	case "highlight":
	    countAndPercentage = addPercentage(key, count)
	    if (countAndPercentage != "")
		$0 = before highlightPrefix text countPrefix countAndPercentage countSuffix highlightSuffix after
	    break
	case "flash":
	    countAndPercentage = addPercentage(key, count)
	    if (countAndPercentage != "")
		tmp = countPrefix countAndPercentage countSuffix
	    # Appending the count during the highlighting adds more characters
	    # to the line. At the end, one instance of those trailing characters
	    # will remain, as the original line is shorter. To avoid that, add
	    # (and backspace) filler spaces to the end.
	    flashAdditionalWidth = length(tmp)

	    if (isQuiet) {
		printf "%s", flash(text tmp, text)
		fflush()
		$0 = after
	    } else {
		printf "%s", before
		$0 = flash(text tmp, text) after
	    }
	    break
	case "file":
	    if (fileUpdateCountDelay != 0) {
		delayedCounts[key]["i"] = lowestI
		delayedCounts[key]["count"] = count
		delayedCounts[key]["text"] = text
	    } else {
		countAndPercentage = addPercentage(key, count)
		if (countAndPercentage != "")
		    writeToFile(text countPrefix countAndPercentage countSuffix)
	    }
	    break
	default:
	    print "Assert: Invalid render: " render > "/dev/stderr"
	    exit 3
    }
}
function renderReset(key, previousCounts, type,      tmp) {
    if (previousCounts == 0) return

    switch (render) {
	case "overlay":
	case "concatenated":
	case "command":
	    delayedChange = delayedChange || (delayedMatch != "") || delayedCounts[key]["count"] != "" || delayedCounts[key]["text"] != ""
	    delayedMatch = ""
	    delete delayedCounts[key]
	    break
	case "highlight":
	    break
	case "flash":
	    break
	case "file":
	    if (type != "regexp") {
		tmp = (type == "count" ? lastCountText[key] : getKeyMatch(key))
		if (fileUpdateCountDelay != 0) {
		    delayedCounts[key]["i"] = lowestI
		    delayedCounts[key]["count"] = 0
		    delayedCounts[key]["text"] = tmp
		} else {
		    writeToFile(tmp countPrefix "0" countSuffix)
		}
	    } else if (fileClearMatchTemplate != "") {
		tmp = gensub(/.*/, fileClearMatchTemplate, 1, lastMatchText)
		if (fileUpdateMatchDelay != 0) {
		    delayedMatchReset = tmp
		} else {
		    writeToFile(tmp)
		}
	    }
	    break
	default:
	    print "Assert: Invalid render: " render > "/dev/stderr"
	    exit 3
    }
}
function resetByName(name,      namePattern, tmp)
{
    if (name ~ /^\/.*\/$/) {
	namePattern = substr(name, 2, length(name) - 2)

	for (tmp in matches) {
	    if (tmp ~ namePattern) {
		resetMatch(tmp)
	    }
	}
	for (tmp in counts) {
	    if (tmp ~ namePattern) {
		resetCount(tmp)
	    }
	}
	for (tmp in matchCounts) {
	    if (tmp ~ namePattern) {
		resetMatchCount(tmp)
	    }
	}
    } else {
	resetMatch(name)
	resetCounts(name)
	resetMatchCounts(name)
    }
}
function addPercentage(key, count,      n, np, npPattern, tmp, sum, percentage, renderedPercentage)
{
    for (n = 1; n <= namePercentagesNum; ++n) {
	np = namePercentages[n]
	if (np ~ /^\/.*\/$/) {
	    npPattern = substr(np, 2, length(np) - 2)
	    if (key !~ npPattern) continue

	    for (tmp in counts) {
		if (tmp ~ npPattern) {
		    sum += counts[tmp]
		}
	    }
	    for (tmp in matchCounts) {
		if (tmp ~ npPattern) {
		    sum += matchCounts[tmp]
		}
	    }
	} else {
	    if (substr(key, 1, length(np)) != np) continue

	    for (tmp in counts) {
		if (substr(tmp, 1, length(np)) == np) {
		    sum += counts[tmp]
		}
	    }
	    for (tmp in matchCounts) {
		if (substr(tmp, 1, length(np)) == np) {
		    sum += matchCounts[tmp]
		}
	    }
	}

	if (sum > 0) {
	    percentage = 100 * count / sum

	    if (percentage < namePercentageThresholds[n])
		return ""

	    renderedPercentage = sprintf("%d %." (percentage < 10 ? namePercentageSingleDigitPrecision : namePercentageMultiDigitPrecision) "f", count, percentage)
	    return gensub(/^(.*) (.*)$/, namePercentageTemplate, 1, renderedPercentage)
	}
    }

    return count
}
function process(type, start, len, pattern, replacement, other, name, priority,      key, tmp) {
    switch (type) {
	case "regexp":
	case "count":
	case "match-count":
	    if (lastPriority != "" && lastPriority > priority) return
		lastPriority = priority
	    break
	case "reset":
	case "reset-name":
	    lastPriority = priority - 1
	    break
	default:
	    print "Assert: Invalid type: " type > "/dev/stderr"
	    exit 3
    }
    switch (type) {
	case "regexp":
	    tmp = replace(substr($0, start, len), pattern, replacement)
	    lastMatchText = tmp
	    key = (name == "" ? pattern : name)
	    ++matches[key]
	    renderMatch(substr($0, 1, start - 1), tmp, substr($0, start + len))
	    break
	case "count":
	    tmp = replace(substr($0, start, len), pattern, replacement)
	    key = name pad(name, "-") pattern
	    lastCountText[key] = tmp
	    renderCount(key, substr($0, 1, start - 1), tmp, ++counts[key], substr($0, start + len))
	    break
	case "match-count":
	    tmp = replace(substr($0, start, len), pattern, replacement)
	    key = name pad(name, "-") tmp
	    renderCount(key, substr($0, 1, start - 1), replace(substr($0, start, len), pattern, replacement), ++matchCounts[key], substr($0, start + len))
	    break
	case "reset":
	    resetMatch(name)
	    resetCount(name)
	    resetMatchCounts(name)
	    break
	case "reset-name":
	    resetByName(name)
	    break
	default:
	    print "Assert: Invalid type: " type > "/dev/stderr"
	    exit 3
    }

    if (other != "") resetByName(other)
}
{
    preRenderLine()

    if (skipPattern == "" || $0 !~ skipPattern) {
	delete seen
	startOffset = 0
	do {
	    lowestOffset = length($0)
	    lowestI = 0
	    for (i = 1; i <= N; i++) {
		if (match(substr($0, startOffset + 1), patterns[i])) {
		    if (seen[i] && ! globals[i]) continue

		    if (startOffset + RSTART < lowestOffset) {
			lowestOffset = startOffset + RSTART
			lowestLength = RLENGTH
			lowestI = i
		    }
		}
	    }

	    if (lowestI == 0) break

	    seen[lowestI] = 1
	    previousLength = length($0)
	    process(types[lowestI], lowestOffset, lowestLength, patterns[lowestI], replacements[lowestI], others[lowestI], names[lowestI], priorities[lowestI])
	    replacementOffset = length($0) - previousLength
	    startOffset = lowestOffset + lowestLength - 1 + replacementOffset

	} while (1)
    }

    postRenderLine()
    if (! isQuiet) print
    postLine()
    if (! isBuffered) fflush()
}
END {
    switch (render) {
	case "highlight":
	case "flash":
	    break
	case "overlay":
	    if (overlayClear != "") {
		printf "%s", overlayClear > file
		if (isBuffered) fflush(file)
	    }
	    break
	case "concatenated":
	    delayedConcatenatedRender()
	    break
	case "command":
	    delayedCommandRender()
	    break
	case "file":
	    delayedFileRender()
	    break
	default:
	    print "Assert: Invalid render: " render > "/dev/stderr"
	    exit 3
    }
}
' "$@"
