#!/bin/bash
###############################################################################
##
# FILE: 	updateTextBlock
# PRODUCT:	tools
# AUTHOR: 	/^--
# DATE CREATED:	30-May-2011
#
###############################################################################
# CONTENTS: 
#   
# REMARKS: 
#
# TODO: 
#   - Implement option to remove content and markers. 
#   - Implement option where to place content when no marker yet. 
#   - Allow to use stdin for either inputfile or file. 
#   - Check that inputfile doesn't contain the end marker. 
#   
# FILE_SCCS = "@(#)updateTextBlock	003	(22-Jun-2011)	tools";
#
# REVISION	DATE		REMARKS 
#	003	22-Jun-2011	FIX: Typo in TMPFILE resolution make it always
#				use the fallback. 
#	002	31-May-2011	Correct help formatting. 
#				Add check for existing inputfile, as sed
#				silently ignores this. 
#				Add sed escaping for pattern and inserted
#				markers, to allow / and \ inside of them. 
#				Add warning for multiple text blocks. 
#	001	30-May-2011	file creation
###############################################################################

printShortUsage()
{
    cat <<SHORTHELPTEXT
Usage: "$(basename "$1")" -u|--update inputfile [-m|--marker markertext | ( -b|--begin-marker text -e|--end-marker text )] file [, ...] [-?|-h|--help]
SHORTHELPTEXT
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments. 
    # It is printed to stderr to avoid accidental processing. 
    printShortUsage "$1" >&2
    cat >&2 <<MOREHELP
Try "$(basename "$1")" --help for more information.
MOREHELP
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument. 
    # It is printed to stdout to allow paging with 'more'. 
    cat <<HELPDESCRIPTION
Update a block of text delimited by markers with text read from an inputfile. 
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --update|-u	inputfile	Update with the contents of inputfile. 
    --marker|-m markertext	Contents are framed by lines containing
				markertext, with appended -BEGIN and -END.
				Default is # INCLUDED-CONTENT
    --begin-marker|-b text	Begin of contents is framed by a line
				containing text. 
    --end-marker|-e text	End of contents is framed by a line containing
				text. 

Example:
"$(basename "$1")" -u myinput /tmp/foobar
HELPTEXT
}

updateFile=
beginMarker='# INCLUDED-CONTENT-BEGIN'
endMarker='# INCLUDED-CONTENT-END'
isCustomBeginMarker=
isCustomEndMarker=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)		shift; printLongUsage "$0"; exit 0;;
	--)			shift; break;;
	--update|-u)		shift; updateFile="$1"; shift;;
	--marker|-m)		shift; beginMarker="$1"; endMarker="$1"; shift;;
	--begin-marker|-b)	shift; beginMarker="$1"; isCustomBeginMarker='true'; shift;;
	--end-marker|-e)	shift; endMarker="$1"; isCustomEndMarker='true'; shift;;
	-*)			{ echo "ERROR: Unknown option \"$1\"!"; echo; printShortUsage "$0"; } >&2; exit 2;;
	*)			break;;
    esac
done
[ $# -eq 0 ] && { echo >&2 "ERROR: Must pass file(s) to process."; printUsage "$0"; exit 2; }
[ "$updateFile" ] || { echo >&2 "ERROR: Must specify inputfile used for the update."; printUsage "$0"; exit 2; }
[ -r "$updateFile" ] || { echo >&2 "ERROR: inputfile \"${updateFile}\" does not exist."; printUsage "$0"; exit 2; }
[ "$isCustomBeginMarker" -a ! "$isCustomEndMarker" -o ! "$isCustomBeginMarker" -a "$isCustomEndMarker" ] && { echo >&2 "ERROR: Must specify both begin and end markers."; printUsage "$0"; exit 2; }


TMPFILE=$(mktemp --tmpdir "$(basename -- "$0")-XXXXXX" 2>/dev/null || echo "${TEMP:-/tmp}/$(basename -- "$0").$$")
cleanup()
{
	rm -f "$TMPFILE" 2>/dev/null
}
[ "$DEBUG" ] || trap 'cleanup' EXIT

escapeSedPattern()
{
    local text=$1
    text=${text//\\/\\\\}
    text=${text////\\/}
    printf %s "$text"
}
escapeSedInsert()
{
    printf %s "${1//\\/\\\\}"
}

isFailure=
for file
do
    # First create a copy of the source file, so that we can atomically replace
    # the original file only after all modifications have succeeded, to avoid
    # spoiling the file in case of intermediate failures. The modification is
    # susceptible to intermediate changes of the file, because the first
    # processing step extracts the line numbers of the markers, and a second
    # step then does the update based on those numbers. 
    cp "$file" "$TMPFILE" || { isFailure='true'; echo >&2 "ERROR: Failed to process ${file}."; continue; }

    # Find and extract the line numbers of the markers. 
    sed -ne "
/^$(escapeSedPattern "$beginMarker")\$/{
=
h
b
}
/^$(escapeSedPattern "$endMarker")\$/{
x
/^$(escapeSedPattern "$beginMarker")\$/=
}
" "$TMPFILE" | {
	read startLine
	read endLine
	read moreLines
	if [ "$moreLines" ]; then
	    echo >&2 "Warning: Multiple text blocks detected in \"$file\"; ignoring all expect the first."
	fi
	if [ "$endLine" ]; then
	    # Replace the existing text block with the inputfile. 
	    # The way to do this with absolute addressing is to delete the
	    # existing range and append the new text block at the end line.
	    # However, the delete command must come last to that the new end
	    # line is not deleted, too. 
	    sed -i -e "
${endLine}a\\
$(escapeSedInsert "$beginMarker")
${endLine}r $updateFile
${endLine}a\\
$(escapeSedInsert "$endMarker")
${startLine},${endLine}d
" "$TMPFILE"
	else
	    # Append the text block with the inputfile at the end of the file. 
	    sed -i -e "
\$a\\
$(escapeSedInsert "$beginMarker")
\$r $updateFile
\$a\\
$(escapeSedInsert "$endMarker")
" "$TMPFILE"
	fi || { echo >&2 "ERROR: Failed to process ${file} in the temporary location."; exit 1; } 
	cp "$TMPFILE" "$file" || { echo >&2 "ERROR: Failed to update ${file}."; exit 1; }
    } || { isFailure='true'; continue; }
done

[ ! "$isFailure" ]
