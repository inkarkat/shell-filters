#!/bin/bash
###############################################################################
##
# FILE: 	updateTextBlock
# PRODUCT:	shell-filters
# AUTHOR: 	/^--
# DATE CREATED:	30-May-2011
#
###############################################################################
# CONTENTS:
#
# REMARKS:
#
# TODO:
#   - Implement option to remove content and markers.
#   - Implement option where to place content when no marker yet.
#   - Allow to use stdin for either inputfile or file.
#   - Check that inputfile doesn't contain the end marker.
#
# @(#)updateTextBlock	$Id$	shell-filters
###############################################################################

printShortUsage()
{
    printf 'Usage: %q %s\n' "$(basename "$1")" '-u|--update inputfile [-m|--marker markertext | ( -b|--begin-marker text -e|--end-marker text )] file [, ...] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Update a block of text delimited by markers with text read from an inputfile.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    cat <<HELPTEXT
    --update|-u	inputfile	Update with the contents of inputfile.
    --marker|-m markertext	Contents are framed by lines containing
				markertext, with appended -BEGIN and -END.
				Default is # INCLUDED-CONTENT
    --begin-marker|-b text	Begin of contents is framed by a line
				containing text.
    --end-marker|-e text	End of contents is framed by a line containing
				text.

Example:
"$(basename "$1")" -u myinput /tmp/foobar
HELPTEXT
}

updateFile=
beginMarker='# INCLUDED-CONTENT-BEGIN'
endMarker='# INCLUDED-CONTENT-END'
isCustomBeginMarker=
isCustomEndMarker=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)		shift; printLongUsage "$0"; exit 0;;
	--)			shift; break;;
	--update|-u)		shift; updateFile="$1"; shift;;
	--marker|-m)		shift; beginMarker="$1"; endMarker="$1"; shift;;
	--begin-marker|-b)	shift; beginMarker="$1"; isCustomBeginMarker='true'; shift;;
	--end-marker|-e)	shift; endMarker="$1"; isCustomEndMarker='true'; shift;;
	-*)			{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)			break;;
    esac
done
if [ $# -eq 0 ]; then
    echo >&2 "ERROR: Must pass file(s) to process."
    echo >&2
    printUsage "$0" >&2
    exit 2
fi
if ! [ "$updateFile" ]; then
    echo >&2 "ERROR: Must specify inputfile used for the update."
    echo >&2
    printUsage "$0" >&2
    exit 2
fi
if ! [ -r "$updateFile" ]; then
    echo >&2 "ERROR: inputfile \"${updateFile}\" does not exist."
    echo >&2
    printUsage "$0" >&2
    exit 2
fi
if [ "$isCustomBeginMarker" -a ! "$isCustomEndMarker" -o ! "$isCustomBeginMarker" -a "$isCustomEndMarker" ]; then
    echo >&2 "ERROR: Must specify both begin and end markers."
    echo >&2
    printUsage "$0" >&2
    exit 2
fi


TMPFILE=$(mktemp --tmpdir "$(basename -- "$0")-XXXXXX" 2>/dev/null || echo "${TEMP:-/tmp}/$(basename -- "$0").$$")
cleanup()
{
	rm -f "$TMPFILE" 2>/dev/null
}
[ "$DEBUG" ] || trap 'cleanup' EXIT

escapeSedPattern()
{
    local text=$1
    text=${text//\\/\\\\}
    text=${text////\\/}
    printf %s "$text"
}
escapeSedInsert()
{
    printf %s "${1//\\/\\\\}"
}

isFailure=
for file
do
    # First create a copy of the source file, so that we can atomically replace
    # the original file only after all modifications have succeeded, to avoid
    # spoiling the file in case of intermediate failures. The modification is
    # susceptible to intermediate changes of the file, because the first
    # processing step extracts the line numbers of the markers, and a second
    # step then does the update based on those numbers.
    cp "$file" "$TMPFILE" || { isFailure='true'; echo >&2 "ERROR: Failed to process ${file}."; continue; }

    # Find and extract the line numbers of the markers.
    sed -ne "
/^$(escapeSedPattern "$beginMarker")\$/{
=
h
b
}
/^$(escapeSedPattern "$endMarker")\$/{
x
/^$(escapeSedPattern "$beginMarker")\$/=
}
" "$TMPFILE" | {
	read startLine
	read endLine
	read moreLines
	if [ "$moreLines" ]; then
	    echo >&2 "Warning: Multiple text blocks detected in \"$file\"; ignoring all expect the first."
	fi
	if [ "$endLine" ]; then
	    # Replace the existing text block with the inputfile.
	    # The way to do this with absolute addressing is to delete the
	    # existing range and append the new text block at the end line.
	    # However, the delete command must come last to that the new end
	    # line is not deleted, too.
	    sed -i -e "
${endLine}a\\
$(escapeSedInsert "$beginMarker")
${endLine}r $updateFile
${endLine}a\\
$(escapeSedInsert "$endMarker")
${startLine},${endLine}d
" "$TMPFILE"
	else
	    # Append the text block with the inputfile at the end of the file.
	    sed -i -e "
\$a\\
$(escapeSedInsert "$beginMarker")
\$r $updateFile
\$a\\
$(escapeSedInsert "$endMarker")
" "$TMPFILE"
	fi || { echo >&2 "ERROR: Failed to process ${file} in the temporary location."; exit 1; }
	cp "$TMPFILE" "$file" || { echo >&2 "ERROR: Failed to update ${file}."; exit 1; }
    } || { isFailure='true'; continue; }
done

[ ! "$isFailure" ]
